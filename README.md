Задание:
Разработать программу оптимизации выбора оборудования. На приобретение оборудования для цеха заданной площади выделена некоторая сумма. Имеется возможность приобрести станки типов А и Б. Известна площадь, занимаемая станками, их стоимость и производительность за сутки. Найти оптимальный вариант закупок, обеспечивающий максимум общей производительности.

Решение:
Для решения данной задачи наиболее подходящим алгоритмом будет генетический алгоритм.
Генетический алгоритм применяется для решения оптимизационных задач, в которых необходимо найти оптимальный набор решений. В данной задаче необходимо найти оптимальный набор оборудования (станков), чтобы обеспечить максимальную производительность при ограниченном бюджете.
Генетический алгоритм работает на основе принципов естественного отбора и эволюции. Он создает популяцию из различных решений (наборов оборудования), затем выбирает лучшие решения и использует их для создания новых потомков. Новые потомки создаются путем скрещивания лучших решений и мутации их хромосом (компонентов).
В данной задаче, генетический алгоритм может использоваться для создания различных комбинаций станков типов А и Б и оценки их производительности, а затем для выбора лучшей комбинации станков, удовлетворяющей ограничениям бюджета и площади.
Таким образом, генетический алгоритм является наиболее подходящим алгоритмом для решения данной задачи.
Нужно определиться с начальной популяцией, которая будет использоваться для генетического алгоритма. В данном случае, начальную популяцию можно сгенерировать случайным образом. Пусть размер начальной популяции будет равен 10 особей. Каждая особь будет состоять из 2 генов, где каждый ген будет представлять выбранное оборудование (0 - станок А, 1 - станок Б).

```
// Создание начальной популяции случайных комбинаций
function createPopulation() {
  const population = [];

  for (let i = 0; i < POPULATION_SIZE; i++) {
    const chromosome = {
      A: Math.floor(Math.random() * (BUDGET / STANKS[0].cost)),
      B: Math.floor(Math.random() * (BUDGET / STANKS[1].cost)),
    };

    population.push(chromosome);
  }

  return population;
}
```
Далее необходимо определить функцию приспособленности, которая будет определять эффективность каждой особи в популяции. В данном случае, функция приспособленности будет определять общую производительность всех станков в каждой особи. Чем выше общая производительность, тем лучше особь и тем выше её значение приспособленности.

```
// Расчет приспособленности хромосомы
function calculateFitness(chromosome) {
  const totalCost =
    chromosome.A * STANKS[0].cost + chromosome.B * STANKS[1].cost;


  const totalArea =
    chromosome.A * STANKS[0].area + chromosome.B * STANKS[1].area;


  const totalProductivity =
    chromosome.A * STANKS[0].productivity +
    chromosome.B * STANKS[1].productivity;


  if (totalCost > BUDGET || totalArea > WORKSHOP_AREA) {
    return 0;
  }


  return totalProductivity;
}
```
В данной функции мы сначала вычисляем общую производительность всех станков в данной особи и проверяем, не превышает ли занимаемая ими площадь максимально допустимую, а также бюджет. Если превышает, то общая производительность устанавливается в 0, так как мы не можем разместить все выбранные станки на доступной площади.
Далее нужно определить операторы генетического алгоритма. В данном случае, мы будем использовать операторы селекции, смешивания и мутации.
Оператор селекции будет использовать турнирную селекцию, где случайным образом выбираются две особи из популяции, и та, у которой значение приспособленности выше, продолжает жить и передаёт свои гены потомкам.

```
// Смешивание генов двух родительских хромосом
function crossover(parent1, parent2) {
  const child = {
    A: 0,
    B: 0,
  };


  const crossoverPoint = Math.floor(
    Math.random() * Object.keys(parent1).length
  );


  let i = 0;


  for (let key in parent1) {
    if (i < crossoverPoint) {
      child[key] = parent1[key];
    } else {
      child[key] = parent2[key];
    }
    i++;
  }
}
```
Метод кроссовера (crossover) является одним из основных операторов в генетическом алгоритме. Он используется для создания новых потомков на основе родительских хромосом.
Суть метода заключается в том, что выбираются две родительские хромосомы, затем случайным образом выбирается точка разрыва (точка кроссовера). Далее происходит обмен генетическим материалом между хромосомами в точке кроссовера, что приводит к созданию двух новых генов.

В результате этого процесса, потомки могут наследовать полезные свойства от обоих родительских хромосом, что может привести к улучшению качества решения. Однако, есть и риск потери полезных свойств, если точка кроссовера попадает на участок, где находятся важные гены.
```
// Мутация генов
function mutation(chromosome) {
  for (let key in chromosome) {
    if (Math.random() < MUTATION_RATE) {
      chromosome[key] += Math.floor(Math.random() * 3) - 1;
    }
  }
  return chromosome;
}
```
Метод мутации в генетическом алгоритме используется для внесения случайных изменений в хромосому (решение), с целью расширения пространства поиска решений и предотвращения сходимости алгоритма к локальному оптимуму.
В процессе мутации, случайно выбирается ген (часть хромосомы) и его значение меняется на другое случайное значение, которое может быть каким-то другим значением в допустимом диапазоне значений гена, так и значением, выходящим за этот диапазон.
Например, если ген представляет собой число, которое может принимать значения от 0 до 9, то при мутации ген может быть изменен на любое значение в этом диапазоне, включая 0 и 9.
Метод мутации позволяет алгоритму изучать большее количество возможных решений и избежать застревания в локальных минимумах, что улучшает эффективность поиска оптимального решения. Однако, чрезмерная мутация может привести к снижению качества решений, поэтому необходимо подбирать оптимальный коэффициент мутации.

```
// Селекция хромосом с помощью рулетки
function selection(population) {
  const totalFitness = population.reduce(
    (total, individual) => total + calculateFitness(individual),
    0
  );
  const selected = [];


  for (let i = 0; i < POPULATION_SIZE; i++) {
    let sum = 0;
    const randomValue = Math.random() * totalFitness;


    for (let j = 0; j < population.length; j++) {
      sum += calculateFitness(population[j]);


      if (sum >= randomValue) {
        selected.push(population[j]);
        break;
      }
    }
  }


  return selected;
}
```
Сначала вычисляем общую приспособленность всей популяции и сохраняем ее в переменной totalFitness. Затем мы выбираем особи для следующего поколения, выбирая их случайным образом, но с учетом их приспособленности.
Мы генерируем случайное число randomValue от 0 до totalFitness и проходимся по всей популяции, прибавляя к переменной sum приспособленность текущей особи. Как только sum становится больше или равно randomValue, мы выбираем эту особь для следующего поколения и переходим к следующему случайному выбору.

#Тесты:

1. тест
```
// Параметры
const POPULATION_SIZE = 15;
const MUTATION_RATE = 0.2;
const GENERATIONS = 10000;

const BUDGET = 500000;
const WORKSHOP_AREA = 10000;

const STANKS = [
  { name: "A", area: 20, cost: 1500, productivity: 50 },
  { name: "B", area: 15, cost: 1000, productivity: 40 },
];
```
[генетический алгоритм][https://github.com/MaksimDziba/genetic-algorithm/images/1.png]

2. тест
```
// Параметры
const POPULATION_SIZE = 15;
const MUTATION_RATE = 0.1;
const GENERATIONS = 100;
```
[генетический алгоритм][https://github.com/MaksimDziba/genetic-algorithm/images/2.png]

3. тест
```
// Параметры
const POPULATION_SIZE = 5;
const MUTATION_RATE = 0.1;
const GENERATIONS = 50;
```
[генетический алгоритм][https://github.com/MaksimDziba/genetic-algorithm/images/3.png]

4. тест
```
// Параметры
const POPULATION_SIZE = 20;
const MUTATION_RATE = 0.5;
const GENERATIONS = 10000;
```
[генетический алгоритм][https://github.com/MaksimDziba/genetic-algorithm/images/4.png]